---
title: 反转链表
tags: [数据结构, 链表]
categories: [剑指offer]
mathjax: true
math: true
date: 2025-08-16 22:32:16
---

# JZ24 反转链表

## 描述

给定一个单链表的头结点$pHead$(该头节点是有值的，比如在下图，它的$val$是1)，长度为$n$，反转该链表后，返回新链表的表头。

<!--more-->

数据范围： $0≤n≤10000≤*n*≤1000$

要求：空间复杂度 $O(1) ，时间复杂度 $O(n)$ 。

如当输入链表${1,2,3}$时，

经反转后，原链表变为${3,2,1}$，所以对应的输出为${3,2,1}$。

以上转换过程如下图所示：![img](../post_images/JZ24)

**示例1**

```
输入：{1,2,3}
返回值：{3,2,1}
```

**示例2**

```
输入：{}
返回值：{}
说明：空链表则输出空                 
```

## 题解1

与JZ1的题解2相同，再写一遍当作C++练习。

其实链表反转与数组交换时思想相似，数组是将其中一个数值保存在临时变量中，而链表则是将$next$指针和$prev$保存在临时指针中。

**代码**

```c++
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    ListNode* ReverseList(ListNode* head) {
        ListNode* prev=NULL;
        ListNode* curr;
        while(head){
            curr = head->next;
            head->next = prev;
            prev = head;
            head = curr;
        }
        return prev;
    }
};
```

**补充图示**：

![反转时指针图示](../post_images/JZ1_1)
