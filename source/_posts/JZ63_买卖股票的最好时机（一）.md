---
title: JZ63 买卖股票的最好时机（一）
tags: [算法,动态规划]
categories: []
mathjax: true
math: true
date: 2025-08-31 22:37:20
---

# JZ63 买卖股票的最好时机（一）

## 描述

假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益

<!--more-->

1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天

2.如果不能获取到任何利润，请返回0

3.假设买入卖出均无手续费

数据范围： $0≤n≤105,0≤val≤104$

要求：空间复杂度 $O(1)$，时间复杂度 $O(n)$

**示例1**

```
输入：[8,9,2,5,4,7,1]
返回值：5
说明：在第3天(股票价格 = 2)的时候买入，在第6天(股票价格 = 7)的时候卖出，最大利润 = 7-2 = 5 ，不能选择在第2天买入，第3天卖出，这样就亏损7了；同时，你也不能在买入前卖出股票。
```

**示例2**

```
输入：[2,4,1]
返回值：2
```
**示例3**

```
输入：[3,2,1]
返回值：0
```

## 题解

对这道题来说，首先需要维护一个最小值$preMin$，因为当考虑子问题：在第$i$天获得的最大收益$dp[i]$时，一定是在第$i$天前的价格最小值购入。

我们设$preMin$为$price[0]$，因为最快也要第0天买入，第1天卖出才能获得收益。

遍历$price$，对$price[i]$来说$dp[i] = max(dp[i-1], price[i] - preMin)$	这里其实是模仿卖出操作。

而后更新$preMin = min(preMin,prices[i])$	这里是模仿以当日价格买入操作。

空间优化一下，$dp[i]$只和前面的最大值相关，所以并不需要储存全部的结果。得$dp = max(dp, price[i] - preMin)$

初始条件：$dp=0,preMin=price[0]$

**代码**

```C++
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param prices int整型vector 
     * @return int整型
     */
    int maxProfit(vector<int>& prices) {
        if(prices.size()<=1) return 0;
        int preMin = prices[0];
        int dp = 0;
        for(int i = 1; i<prices.size();i++){
            dp = max(dp,prices[i]-preMin);
            preMin = min(preMin,prices[i]);
        }
        return dp;
    }
};
```

