---
title: LeetCode2716
tags: [哈希表,字符串]
categories: [LeetCode每日一题, LeetCode简单]
mathjax: true
math: true
date: 2025-03-30 00:31:29
---

# [LeetCode.2716](https://leetcode.cn/problems/minimize-string-length):最小化字符串长度

​	这道题的核心就是把题干等价化，题干叽里咕噜说了半天，实际上就是把字符串中独特的字母找出来，直接用哈希表解决即可。

<!--more-->

## 题目描述

给你一个下标从 **0** 开始的字符串 `s` ，重复执行下述操作 **任意** 次：

- 在字符串中选出一个下标 `i` ，并使 `c` 为字符串下标 `i` 处的字符。并在 `i` **左侧**（如果有）和 **右侧**（如果有）各 **删除** 一个距离 `i` **最近** 的字符 `c` 。

请你通过执行上述操作任意次，使 `s` 的长度 **最小化** 。

返回一个表示 **最小化** 字符串的长度的整数。

## 示例

示例1：

```
输入：s = "aaabc"
输出：3
解释：在这个示例中，s 等于 "aaabc" 。我们可以选择位于下标 1 处的字符 'a' 开始。接着删除下标 1 左侧最近的那个 'a'（位于下标 0）以及下标 1 右侧最近的那个 'a'（位于下标 2）。执行操作后，字符串变为 "abc" 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 3 。
```

示例2：

```
输入：s = "cbbd"
输出：3
解释：我们可以选择位于下标 1 处的字符 'b' 开始。下标 1 左侧不存在字符 'b' ，但右侧存在一个字符 'b'（位于下标 2），所以会删除位于下标 2 的字符 'b' 。执行操作后，字符串变为 "cbd" 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 3 。
```

示例3：

```
输入：s = "dddaaa"
输出：2
解释：我们可以选择位于下标 1 处的字符 'd' 开始。接着删除下标 1 左侧最近的那个 'd'（位于下标 0）以及下标 1 右侧最近的那个 'd'（位于下标 2）。执行操作后，字符串变为 "daaa" 。继续对新字符串执行操作，可以选择位于下标 2 的字符 'a' 。接着删除下标 2 左侧最近的那个 'a'（位于下标 1）以及下标 2 右侧最近的那个 'a'（位于下标 3）。执行操作后，字符串变为 "da" 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 2 。
```

提示：

```
1 <= s.length <= 100
s 仅由小写英文字母组成
```

## 我的题解

​	还是那句话，题干叽里咕噜说了半天，可以任意次从字符串中选定一个字符，然后在它左侧或者右侧各删除一个距离它最近的相同字符，还加了一句$左侧(如果有)$和$右侧(如果有)$。那岂不就是说可以任意删除一个与选定字符相同的字符，所以说删到最后不就剩它本身删不掉了。

​	使用set统计s中有多少种字符即可。

## 代码

```c++
class Solution {
public:
    int minimizedStringLength(string s) {
        int n = s.length();
        set<int> check;
        for(int i = 0; i < n; i++){
            if(check.count(s[i] - 'a') == 0){
                check.insert(s[i] - 'a');
            }
        }
        return check.size();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 *n* 是字符串 *s* 的长度。
- 空间复杂度：$O(1)$。

## std::set用法

$set.count(i):$ 查找$set$中$i$的数量，因为$set$中的元素是独特的，故而只会返回1或者0，而1代表$set$中存在元素$i$，0自然代表该$set$中不存在元素$i$。

$set.insert(i)：$向集合$set$中插入元素$i$，如果已存在，则忽略。也就是说可以重复插入同一个元素，但是只会储存一次。
