---
title: JZ61 扑克牌顺子
tags: [算法,模拟]
categories: [剑指offer]
mathjax: true
math: true
date: 2025-11-06 11:32:09
---

# JZ61 扑克牌顺子

## 描述

现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。

<!--more-->

```
有如下规则：
1. A为1，J为11，Q为12，K为13，A不能视为14
2. 大、小王为 0，0可以看作任意牌
3. 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。
4.数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]
```

要求：空间复杂度$O(1)$，时间复杂度 $O(nlogn)$，本题也有时间复杂度$O(n)$的解法

**示例1**

```python
输入：[6,0,2,0,4]
返回值：true
说明：中间的两个0一个看作3，一个看作5 。即：[6,3,2,5,4]
	这样这五张牌在[2,6]区间连续，输出true 
```

**示例2**

```python
输入：[0,3,2,6,4]
返回值：true
```

**示例3**

~~~python
输入：[1,0,0,1,0]
返回值：false
~~~

**示例4**

```python
输入：[13,12,11,0,1]
返回值：false
```

## 题解

最初我考虑的是在每两个相邻之间检查是否有足够的大小王能够塞进去填充，后面看了讨论发现我的思路还是过于**纯真**的模拟了。只要首先排序之后统计相邻两张牌的$gap$，然后看大小王是否足够总的$gap$就可以了。

**代码**

```python
# 
# @param numbers int整型一维数组 
# @return bool布尔型
#
class Solution:
    def IsContinuous(self , numbers: List[int]) -> bool:
        nOfZeros = numbers.count(0)
        numbers.sort()
        sumOfGap = 0
        for i in range(nOfZeros, len(numbers)-1):
            if(numbers[i]==numbers[i+1]):
                return False
            else:
                sumOfGap += (numbers[i+1]-numbers[i])-1
        if(sumOfGap > nOfZeros):
            return False
        return True
```

