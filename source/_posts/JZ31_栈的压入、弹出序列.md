---
title: JZ31 栈的压入、弹出序列
tags: [数据结构,队列&栈]
categories: [剑指offer]
mathjax: true
math: true
date: 2025-08-28 18:51:17
---

# JZ31  栈的压入、弹出序列

## 描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。

<!--more-->

例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。

- $0<=pushV.length == popV.length <=1000$
- $-1000<=pushV[i]<=1000$
- $pushV$ 的所有数字均不相同

**示例1**

```
输入：[1,2,3,4,5],[4,5,3,2,1]
返回值：true
说明：
可以通过
push(1)=>push(2)=>push(3)=>push(4)=>pop()=>push(5)=>pop()=>pop()=>pop()=>pop()
这样的顺序得到[4,5,3,2,1]这个序列，返回true
```

**示例2**

```
输入：[1,2,3,4,5],[4,3,5,1,2]
返回值：false
说明：
由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2前压入，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false      
```

## 题解

初见思路：压入顺序一定是正确的，只需要判断弹出顺序是否是对的即可。按照压入顺序开始压入，直到压入到弹出顺序中的第一个为止，从此开始，只要弹出的和已经压入的栈顶元素不相同，就尝试压入下一个元素，如果下一个元素不是弹出的元素，则返回错误即可，直到弹出序列结束为止。

实际上每次压入之后都可以进行弹出判断，每次压入之后都尝试弹出即可。

**代码**

```C++
#include <stack>
class Solution {
  public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param pushV int整型vector
     * @param popV int整型vector
     * @return bool布尔型
     */
    bool IsPopOrder(vector<int>& pushV, vector<int>& popV) {
        int pushCount = 0;
        int popCount = 0;
        stack<int> st;
        while (pushCount < pushV.size()) {
            st.push(pushV[pushCount]);
            pushCount++;

            while (!st.empty() && popCount < popV.size() && st.top() == popV[popCount]) {
                st.pop();
                popCount++;
            }

        }

        if (popCount==popV.size()) return true;
        return false;
    }
};
```

